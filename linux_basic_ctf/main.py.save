import os
import math
import datetime
# import readline # Agar readline ni ishlatmoqchi bo'lsangiz, uni saqlab qoling


# --- Asosiy sozlamalar ---
REAL_OS_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "OS")
current_directory_path = REAL_OS_PATH

# Foydalanuvchi nomi va host nomi endi o'zgaruvchan bo'ladi
USER_NAME = "user" # Dastlabki qiymat, keyin foydalanuvchi kiritadi
HOST_NAME = "ctf-linux"

# ANSI rang kodlari (Zsh ga o'xshash ranglar)
COLOR_PROMPT_USER_HOST = "\033[32m" # Yashil rang
COLOR_PROMPT_PATH = "\033[34m"      # Ko'k rang
COLOR_DIR = "\033[94m"              # Papkalar uchun yorqin ko'k
COLOR_FILE = "\033[0m"              # Fayllar uchun odatiy rang (oq/kulrang)
COLOR_EXEC = "\033[32m"             # Executable fayllar uchun yashil
COLOR_RESET = "\033[0m"             # Rangni tiklash

# Yangi ranglar - hacking style uchun
COLOR_HACKING_RED = "\033[31m"      # Qizil
COLOR_HACKING_GREEN = "\033[32m"    # Yashil
COLOR_HACKING_YELLOW = "\033[33m"   # Sariq
COLOR_HACKING_CYAN = "\033[36m"     # Moviy-yashil
COLOR_HACKING_MAGENTA = "\033[35m"  # Fiolet
COLOR_HACKING_BOLD = "\033[1m"      # Qalin shrift


# --- Yordamchi funksiyalar (o'zgarmagan qismi) ---

def get_display_path_string():
    if current_directory_path == REAL_OS_PATH:
        return "~"
    relative_path = os.path.relpath(current_directory_path, REAL_OS_PATH)
    if relative_path == ".":
        return "~"
    return f"~/{relative_path}"

def resolve_real_path(input_path):
    if input_path.startswith("/"):
        if input_path.startswith("/OS") or input_path.startswith("/os"):
            relative_part = input_path[len("/OS"):] if input_path.startswith("/OS") else input_path[len("/os"):]
            if not relative_part:
                return REAL_OS_PATH
            return os.path.abspath(os.path.join(REAL_OS_PATH, relative_part.lstrip('/')))
        else:
            return input_path
    else:
        return os.path.abspath(os.path.join(current_directory_path, input_path))

# --- ls_command va uning yordamchi funksiyalari (avvalgi javobdagi yangilangan versiyasi) ---

def get_permissions_string(st_mode):
    perms = ['-'] * 10
    if os.path.isdir(st_mode):
        perms[0] = 'd'

    perms[1] = 'r' if (st_mode & 0o400) else '-'
    perms[2] = 'w' if (st_mode & 0o200) else '-'
    perms[3] = 'x' if (st_mode & 0o100) else '-'

    perms[4] = 'r' if (st_mode & 0o040) else '-'
    perms[5] = 'w' if (st_mode & 0o020) else '-'
    perms[6] = 'x' if (st_mode & 0o010) else '-'

    perms[7] = 'r' if (st_mode & 0o004) else '-'
    perms[8] = 'w' if (st_mode & 0o002) else '-'
    perms[9] = 'x' if (st_mode & 0o001) else '-'

    return "".join(perms)


def ls_command(args_str=None):
    show_hidden = False
    long_format = False
    target_path_arg = None

    args_list = args_str.split() if args_str else []

    for arg in args_list:
        if arg == "-a":
            show_hidden = True
        elif arg == "-l":
            long_format = True
        elif arg == "-la" or arg == "-al":
            show_hidden = True
            long_format = True
        elif arg.startswith("-"):
            print(f"ls: invalid option -- '{arg.lstrip('-')}'")
            return
        else:
            target_path_arg = arg
            
    target_path = None
    if target_path_arg is None or target_path_arg == ".":
        target_path = current_directory_path
    else:
        target_path = resolve_real_path(target_path_arg)
            
    if not target_path.startswith(REAL_OS_PATH):
        print(f"ls: '{target_path_arg}': Permission denied (Cannot access outside OS folder)")
        return

    if not os.path.exists(target_path):
        print(f"ls: '{target_path_arg}': No such file or directory")
        return
            
    if os.path.isfile(target_path):
        if os.access(target_path, os.X_OK):
            print(f"{COLOR_EXEC}{os.path.basename(target_path)}{COLOR_RESET}")
        else:
            print(f"{COLOR_FILE}{os.path.basename(target_path)}{COLOR_RESET}")
        return

    if os.path.isdir(target_path):
        items = []
        try:
            all_items = os.listdir(target_path)
                        
            for item_name in sorted(all_items):
                if not show_hidden and item_name.startswith('.'):
                    continue
                                
                full_item_path = os.path.join(target_path, item_name)
                                
                display_name = item_name
                if os.path.isdir(full_item_path):
                    display_name = f"{COLOR_DIR}{item_name}/{COLOR_RESET}"
                elif os.path.isfile(full_item_path):
                    if os.access(full_item_path, os.X_OK):
                        display_name = f"{COLOR_EXEC}{item_name}{COLOR_RESET}"
                    else:
                        display_name = f"{COLOR_FILE}{item_name}{COLOR_RESET}"
                else:
                    display_name = f"{COLOR_FILE}{item_name}{COLOR_RESET}"
                                
                if long_format:
                    try:
                        stat_info = os.stat(full_item_path)
                        perms = get_permissions_string(stat_info.st_mode)
                        nlink = stat_info.st_nlink
                        owner_name = "user"
                        group_name = "user"
                        size = stat_info.st_size
                        mod_time = datetime.datetime.fromtimestamp(stat_info.st_mtime).strftime('%b %d %H:%M')
                                                
                        long_entry = f"{perms} {nlink:2} {owner_name:8} {group_name:8} {size:8} {mod_time} {display_name}"
                        items.append(long_entry)
                    except OSError:
                        items.append(f"????????? {display_name} (Permission denied for stat)")
                else:
                    items.append(display_name)
                        
            num_items = len(items)
            if num_items == 0:
                print("Empty directory.")
                return

            print()

            if long_format:
                for item in items:
                    print(item)
            else:
                COLUMNS = 3
                max_len = 0
                for item in items:
                    clean_item = item.replace(COLOR_DIR, "").replace(COLOR_FILE, "").replace(COLOR_EXEC, "").replace(COLOR_RESET, "")
                    max_len = max(max_len, len(clean_item))
                                
                column_width = max_len + 4

                rows_per_column = math.ceil(num_items / COLUMNS)
                        
                for r in range(rows_per_column):
                    line = []
                    for c in range(COLUMNS):
                        idx = r + c * rows_per_column
                        if idx < num_items:
                            item_display = items[idx]
                            clean_item = item_display.replace(COLOR_DIR, "").replace(COLOR_FILE, "").replace(COLOR_EXEC, "").replace(COLOR_RESET, "")
                            padding_needed = column_width - len(clean_item)
                            line.append(item_display + " " * padding_needed)
                        else:
                            line.append(" " * column_width)
                    print("".join(line))
                
        except PermissionError:
            print(f"ls: '{target_path_arg}': Permission denied")
        except OSError as e:
            print(f"ls: '{target_path_arg}': Error: {e}")
    else:
        print(f"ls: '{target_path_arg}': Not a directory")

# --- Qolgan buyruq funksiyalari (o'zgarmagan) ---
def cd_command(target_path):
    global current_directory_path
    if not target_path or target_path == "~":
        current_directory_path = REAL_OS_PATH
        return
    resolved_target = resolve_real_path(target_path)
    if not resolved_target.startswith(REAL_OS_PATH):
        print(f"cd: '{target_path}': Permission denied (Cannot navigate outside OS folder)")
        return
    if not os.path.exists(resolved_target):
        print(f"cd: '{target_path}': No such file or directory")
        return
    if os.path.isdir(resolved_target):
        current_directory_path = resolved_target
    else:
        print(f"cd: '{target_path}': Not a directory")

def cat_command(filename):
    resolved_file = resolve_real_path(filename)
    if not resolved_file.startswith(REAL_OS_PATH):
        print(f"cat: '{filename}': Permission denied (Cannot access files outside OS folder)")
        return
    if not os.path.exists(resolved_file):
        print(f"cat: '{filename}': No such file or directory")
        return
    if os.path.isfile(resolved_file):
        try:
            with open(resolved_file, 'r', encoding='utf-8', errors='ignore') as f:
                print(f.read())
        except PermissionError:
            print(f"cat: '{filename}': Permission denied")
        except Exception as e:
            print(f"cat: '{filename}': Error reading file: {e}")
    else:
        print(f"cat: '{filename}': No such file or directory")

def mkdir_command(dirname):
    full_path = os.path.join(current_directory_path, dirname)
    if not full_path.startswith(REAL_OS_PATH):
        print(f"mkdir: '{dirname}': Permission denied (Cannot create directory outside OS folder)")
        return
    if os.path.exists(full_path):
        print(f"mkdir: '{dirname}': File exists")
    else:
        try:
            os.mkdir(full_path)
            print(f"Directory '{dirname}' created.")
        except PermissionError:
            print(f"mkdir: '{dirname}': Permission denied")
        except OSError as e:
            print(f"mkdir: '{dirname}': Error: {e}")

def touch_command(filename, content=""):
    full_path = os.path.join(current_directory_path, filename)
    if not full_path.startswith(REAL_OS_PATH):
        print(f"touch: '{filename}': Permission denied (Cannot create file outside OS folder)")
        return
    if os.path.isdir(full_path):
        print(f"touch: '{filename}': Is a directory")
    else:
        try:
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"File '{filename}' created or updated.")
        except PermissionError:
            print(f"touch: '{filename}': Permission denied")
        except Exception as e:
            print(f"touch: '{filename}': Error: {e}")

def help_command():
    print("""
Available commands:
  ls [path]         - Lists files and directories in the current or specified path.
                      Use 'ls' without arguments for current directory.
                      If the argument is a file, it just shows that file.
                      Options: -a (show hidden files), -l (long format), -la or -al (both).
  cd [path]         - Changes directory. Use '..' to go up.
                      'cd' or 'cd ~' returns to the base 'OS' folder.
  cat <filename>    - Displays the content of a file.
  mkdir <dirname>   - Creates a new directory.
  touch <filename> [content] - Creates a new file or updates an existing file with content.
  help              - Displays this list of commands.
  clear             - Clears the terminal screen.
  exit              - Exits the program.
""")

def clear_command():
    os.system('cls' if os.name == 'nt' else 'clear')


# --- Yangi avtentifikatsiya funksiyasi ---
def authenticate_user():
    global USER_NAME # Foydalanuvchi nomini global o'zgartirish uchun
    
    max_attempts = 3
    attempts = 0
    
    while attempts < max_attempts:
        username_input = input("Username: ").strip()
        password_input = input("Password: ").strip() # Parolni yashirish uchun getpass.getpass() ishlatish mumkin

        # Katta-kichik harflar farqi bo'lmasligi uchun .lower() ishlatamiz
        if username_input.lower() == "red" and password_input == "dedsec":
            USER_NAME = "stalker" # Foydalanuvchi nomini o'rnatamiz
            print(f"\n{COLOR_HACKING_GREEN}{COLOR_HACKING_BOLD}Authentication successful. Welcome to PROJECT DEDSEC!{COLOR_RESET}\n")
            return True
e
        else:
            attempts += 1
            print(f"Authentication failed. {max_attempts - attempts} attempts remaining.")
            if attempts == max_attempts:
                print(f"{COLOR_HACKING_RED}Too many failed attempts. Exiting.{COLOR_RESET}")
                return False

def run_ctf_terminal():

    ascii_logo = rf"""
{COLOR_HACKING_CYAN}▖  ▖  ▜     {COLOR_RESET}{COLOR_HACKING_RED}       ▗     ▄    ▌▄▖    {COLOR_RESET}
{COLOR_HACKING_CYAN}▌▞▖▌█▌▐ ▛▘▛▌▛▛▌█▌  {COLOR_RESET}{COLOR_HACKING_RED}▜▘▛▌  ▌▌█▌▛▌▚ █▌▛▘{COLOR_RESET}
{COLOR_HACKING_CYAN}▛ ▝▌▙▖▐▖▙▖▙▌▌▌▌▙▖  {COLOR_RESET}{COLOR_HACKING_RED}▐▖▙▌  ▙▘▙▖▙▌▄▌▙▖▙▖{COLOR_RESET} {COLOR_HACKING_GREEN}{COLOR_HACKING_BOLD}Little Red{COLOR_RESET}

{COLOR_HACKING_YELLOW}{COLOR_HACKING_BOLD}remember they’re listening!!!{COLOR_RESET}
"""
    print(ascii_logo)

    print(f"{COLOR_HACKING_YELLOW}Type 'help' for available commands.{COLOR_RESET}")
    
    while True:
        # Prompt endi global USER_NAME o'zgaruvchisidan foydalanadi
        display_path = get_display_path_string()
        prompt = f"{COLOR_PROMPT_USER_HOST}{USER_NAME}@{HOST_NAME}{COLOR_RESET}:{COLOR_PROMPT_PATH}{display_path}{COLOR_RESET}$ "
        
        user_input = input(prompt).strip()
        
        if not user_input:
            continue

        parts = user_input.split(" ", 1)
        command = parts[0]
        args = parts[1] if len(parts) > 1 else ""

        if command == "exit":
            print("Exiting terminal.")
            break
        elif command == "ls":
            ls_command(args)
        elif command == "cd":
            cd_command(args)
        elif command == "cat":
            cat_command(args)
        elif command == "mkdir":
            mkdir_command(args)
        elif command == "touch":
            filename_parts = args.split(" ", 1)
            touch_filename = filename_parts[0]
            touch_content = filename_parts[1] if len(filename_parts) > 1 else ""
            touch_command(touch_filename, touch_content)
        elif command == "help":
            help_command()
        elif command == "clear":
            clear_command()
        else:
            print(f"{command}: Command not found")

# Dasturni ishga tushirish
if __name__ == "__main__":
    if not os.path.exists(REAL_OS_PATH):
        print(f"The '{REAL_OS_PATH}' folder was not found. Creating it now...")
        try:
            os.makedirs(REAL_OS_PATH)
            print(f"Folder '{REAL_OS_PATH}' created successfully.")
        except Exception as e:
            print(f"Error creating '{REAL_OS_PATH}' folder: {e}")
            print("Please create the 'OS' folder manually in the same directory as 'main.py' and try again.")
            exit()
    elif not os.path.isdir(REAL_OS_PATH):
        print(f"Error: '{REAL_OS_PATH}' exists but is not a directory. Please ensure it is a folder.")
        exit()

    # Avtentifikatsiyani terminal ishga tushishidan oldin chaqiramiz
    if authenticate_user():
        run_ctf_terminal()
    else:
        # Avtentifikatsiya muvaffaqiyatsiz bo'lsa, dastur tugaydi
        pass
